#+TITLE: doxa

a simple in-memory database, trying to copy the best solutions from [[https://github.com/tonsky/datascript][datascript]],
[[https://github.com/xtdb/xtdb/][xtdb]], [[https://github.com/fulcrologic/fulcro][fulcro]], [[https://github.com/lilactown/autonormal][autonormal]] and especially [[https://github.com/thheller/shadow-experiments/blob/master/src/main/shadow/experiments/grove/db.cljc][shadow-grove]]. each of them has its own
strengths, and is an excellent solution, but each lacks some of the cool things
that the others have. =doxa= tries to take the best from every solution while
being damn fast and lightweight.

* rationale

one of the biggest challenges when working on the front end is state management.
[[https://github.com/day8/re-frame][re-frame]] was one of the first solutions to propose one central =app-db=, one source of
truth. solution works great, but as the application grows, there is a problem
with data denormalization and fatigue with multiple nested maps.

the ideal solution seems to be =datascript=, but there have been several attempts
to incorporate it into the =re-frame= ecosystem, eg. [[https://github.com/mpdairy/posh][posh]] and [[https://github.com/denistakeda/re-posh][re-posh]], and in my
humble opinion, despite much desire and hard work, the transplant has failed.
datascript seems to be too heavy for the frontend. it's not necessarily because
it's too slow for normal use, it's because =clojurescript= itself has additional
overhead compared to =js=, and there's always the chase for numbers and
optimization for lighthouse. much bigger inconvenience is that
datascript is built around its own data types. =re-frame= has a whole bunch of
tools with [[https://github.com/day8/re-frame-10x][re-frame-10x]] that allow you to preview =app-db= in real time.
=shadow-cljs= also offers =tap>= and there is no problem to spit out entire =app-db=
and check each individual map, leaf and node.

=doxa= is an attempt to create a normalized db based on a simple =hashmap=, that
allows you to edit data both using =clojure.core= functions like =assoc=, =assoc-in=,
and using transactions similar to =datascript=. in addition, it offers the ability
to use =datalog= and =pull/eql= queries, as well as =clojure.core= =filter=, =map=, =keep=,
=take= and all the data processing features we love. due to being built around 3
nested maps, pretending to be a =triplestore=, it allows to use the whole =clojure=
ecosystem operating around maps, like =malli=, =spec=, =specter=, =meander= etc.

* db structure
:PROPERTIES:
:ID:       b281c1be-a657-4a21-a828-99e929558302
:END:

#+begin_src clojure :results silent :exports code

(require '[ribelo.doxa     :as dx])
(require '[meander.epsilon :as  m])

#+end_src

=db= is a simple map with three levels of nesting

#+begin_src clojure :results silent :exports code

{?table {?eid {:db/id ?eid
               ?k     ?v}}
 ...    {...  {:db/id ...}}}

;;eg

{:person/id {1 {:person/id 1 :name "ivan" :age 18}
             2 {:person/id 2 :name "petr" :age 24 :friend [:person/id 1]}}}

#+end_src

why not flat map? because this design allows for greater flexibility when it
comes to the operation of references and naming entity. =[person/id :ivan]= looks
better than =:person.id/ivan=, is easier to create and easier to use.

but wouldn't operations on a flat map be faster? in normal use, the speed
difference is negligible, while a nested map can be faster than =datascript= due
to the possibility of limiting the iterated elements, see [[https://github.com/ribelo/doxa#can-we-be-faster-than-datascript-yes][benchmark]]

* usage examples

** transactions

#+begin_src clojure :results silent

(def data [{:db/id 1 :name "Petr" :aka ["Devil"]}])

(def db (dx/create-dx data)
  ;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}
  )

#+end_src

each map that is supposed to be an =entity= needs a key with one of the =#{"id"
"by-id" "list"}= suffixes, which are defined in the dynamic variable
=dx/*id-sufixes*=, if that wasn't enough

=doxa= tries to use the full potential of =meander= and be as forgiving as possible
with the data it receives. =commit= can accept either a single =transaction= or any
collection of =transtactions= that is =sequable?=.

the reference of =transaction= can be a =map= or =lookup-ref=, the arguments can be a
=key-value pair=, where the value can be anything, a =map=, a =variable=, a =collection
of anything=, a lookup-ref etc. Arguments can be mixed and mangled. data
automatically normalizes, adds and is converted into =lookup-ref= or =collection of
lookup-refs= if needed and required.

*** put

**** add entity

#+begin_src clojure :results silent :exports code

(dx/commit {} [[:dx/put {:db/id 1 :name "David" :aka ["Devil"]}]])
;; => #:db{:id {1 {:db/id 1, :name "David", :aka ["Devil"]}}}

(dx/commit {} [:dx/put [:db/id 1] {:name "David" :aka ["Devil"]}])
;; => #:db{:id {1 {:name "David", :aka ["Devil"], :db/id 1}}}

#+end_src


**** single keyword change

#+begin_src clojure :results silent :exports code

(dx/commit db [[:dx/put [:db/id 1] :name "David"]])
;; => #:db{:id {1 {:db/id 1, :name "David", :aka ["Devil"]}}}

(dx/commit db [[:dx/put [:db/id 1] :aka ["Tupen"]]])
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Tupen"]}}}

#+end_src

**** multiple kv

#+begin_src clojure :results silent :exports code

db
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

(dx/commit db [:dx/put [:db/id 1] :name "Ivan" :age 18 :aka ["Tupen"]])
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Tupen"]}}}
#+end_src


**** add data with autonormalization

#+begin_src clojure :results silent :exports code

(dx/commit db [[:dx/put [:db/id 1] :friend [{:db/id 2 :name "Ivan"} {:db/id 3 :name "Lucy"}]]])
;; =>
;; #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"], :friend [[:db/id 2] [:db/id 3]]},
;;           2 {:db/id 2, :name "Ivan"},
;;           3 {:db/id 3, :name "Lucy"}}}

#+end_src

*** delete

deleting data automatically cleans up the database. i.e. if you delete an
=entity=, all =look-up refs= refering to it will be deleted at the same time. if you
delete the last =map entry= from a map, the whole map will be deleted etc.


**** delete entity

#+begin_src clojure :results silent :exports code

(dx/commit db [[:dx/delete [:db/id 1]]])
;; => {}

#+end_src


**** delete keyword

#+begin_src clojure :results silent :exports code

(dx/commit db [[:dx/delete [:db/id 1] :aka]])
;; => #:db{:id {1 {:db/id 1, :name "Petr"}}}

(dx/commit db [[:dx/delete [:db/id 1] :aka]
               [:dx/delete [:db/id 1] :name]])
;; => {}

#+end_src


**** remove elem from vector

#+begin_src clojure :results silent :exports code

db
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

(dx/commit db [[:dx/delete [:db/id 1] :aka "Devil"]])
;; => #:db{:id {1 {:db/id 1, :name "Petr"}}}

#+end_src


**** remove an invalid key

#+begin_src clojure :results silent :exports code
db
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

(dx/commit db [[:dx/delete [:db/id 1] :AKA "Devil"]])
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

#+end_src


*** conj

because =doxa= is schemeless, if we want to add something to the vector we have to
use =:dx/conj=

**** add elem

#+begin_src clojure :results silent :exports code

db
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

(dx/commit db [[:dx/conj [:db/id 1] :aka "Tupen"]])
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil" "Tupen"]}}}

(dx/commit db [[:dx/conj [:db/id 1] :name "Ivan"]])
;; => #:db{:id {1 {:db/id 1, :name ["Petr" "Ivan"], :aka ["Devil"]}}}

#+end_src


**** with autonormalisation

#+begin_src clojure :results silent :exports code

db
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

(dx/commit db [[:dx/conj [:db/id 1] :friend {:db/id 2 :name "Ivan"}]])
;; =>
;; #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"], :friend [[:db/id 2]]},
;;           2 {:db/id 2, :name "Ivan"}}}

(dx/commit db [[:dx/conj [:db/id 1] :friend [{:db/id 2 :name "Ivan"} {:db/id 3 :name "Lucy"}]]])
;; =>
;; #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"], :friend [[:db/id 2] [:db/id 3]]},
;;           2 {:db/id 2, :name "Ivan"}, 3
;;           {:db/id 3, :name "Lucy"}}}

#+end_src

*** merge

=:dx/merge= can easily be replaced by update, but using a specialized transaction
allows for speed optimizations and a few other minor things

#+begin_src clojure :results silent :exports code

db
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

(dx/commit db [:dx/merge [:db/id 1] {:age 18}])
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"], :age 18}}}
#+end_src


*** update

#+begin_src clojure :results silent :exports code

db
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

(dx/commit db [[:dx/update [:db/id 1] assoc :aka "Tupen"]])
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka "Tupen"}}}

(dx/commit db [[:dx/update [:db/id 1] :aka conj "Tupen"]])
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil" "Tupen"]}}}

#+end_src


*** match

just like in =xtdb=, we can use match. if data match, =db= is returned unchanged,
otherwise =nil=.


**** match entity

#+begin_src clojure :results silent :exports code

db
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

(dx/commit db [[:dx/match [:db/id 1] {:db/id 1 :name "Petr", :aka ["Devil"]}]])
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

#+end_src


**** match keyword

#+begin_src clojure :results silent :exports code

db
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

(dx/commit db [[:dx/match [:db/id 1] :aka ["Devil"]]])
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

#+end_src

**** conditional put


#+begin_src clojure :results silent :exports code

db
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

(dx/commit db [[:dx/match [:db/id 1] :aka ["Devil"]]
               [:dx/put   [:db/id 1] :aka ["Tupen"]]])
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Tupen"]}}}

#+end_src


**** conditional delete

#+begin_src clojure :results silent :exports code

db
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

(dx/commit db [[:dx/match  [:db/id 1]  :aka ["Tupen"]]
               [:dx/delete [:db/id 1] :aka]])
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

#+end_src

transactions are dropped until the next valid match occurs

#+begin_src clojure :results silent :export code

db
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"]}}}

(dx/commit db [[:dx/match [:db/id 1] :aka ["Tupen"]]       ;; unmatched
               [:dx/put [:db/id 1] :age 15]                ;;    skiped
               [:dx/match [:db/id 1] :name "Petr"]         ;;   matched
               [:dx/put [:db/id 1] :sex :male]])           ;;  commited
;; => #:db{:id {1 {:db/id 1, :name "Petr", :aka ["Devil"], :sex :male}}}

#+end_src

** pull

#+begin_src clojure :results silent :exports code

(def people-docs
  [{:db/id 1, :name "Petr", :aka ["Devil" "Tupen"] :child [[:db/id 2] [:db/id 3]]}
   {:db/id 2, :name "David", :father [[:db/id 1]]}
   {:db/id 3, :name "Thomas", :father [[:db/id 1]]}
   {:db/id 4, :name "Lucy" :friend [[:db/id 5]], :enemy [[:db/id 6]]}
   {:db/id 5, :name "Elizabeth" :friend [[:db/id 6]], :enemy [[:db/id 7]]}
   {:db/id 6, :name "Matthew", :father [[:db/id 3]], :friend [[:db/id 7]], :enemy [[:db/id 8]]}
   {:db/id 7, :name "Eunan", :friend [[:db/id 8]], :enemy [[:db/id 4]]}
   {:db/id 8, :name "Kerri"}
   {:db/id 9, :name "Rebecca"}])

(def db (dx/create-dx people-docs))

#+end_src


*** eql

#+begin_src clojure :results silent :exports code

(dx/pull db {[:db/id 1] [:name :aka]})
;; => {:name "Petr", :aka ["Devil"]}

#+end_src


*** datomic like pull syntax

#+begin_src clojure :results silent :exports code

(dx/pull db [:name :aka] [:db/id 1])
;; => {:name "Petr", :aka ["Devil"]}

#+end_src


**** simple query

#+begin_src clojure :results silent :exports code

(dx/pull db  [:name :father :db/id] [:db/id 6])
;; => {:name "Matthew", :father [:db/id 3], :db/id 6}

#+end_src

**** pull many


#+begin_src clojure :results silent :exports code

(dx/pull db [:name] [[:db/id 1] [:db/id 5] [:db/id 7] [:db/id 9]])
;; => [{:name "Petr"} {:name "Elizabeth"} {:name "Eunan"} {:name "Rebecca"}]

#+end_src

**** reverse search


#+begin_src clojure :results silent :exports code

(dx/pull db [:name :_child] [:db/id 2])
;; => {:name "David", :_child [:db/id 1]}

(dx/pull db [:name {:_child [:name]}] [:db/id 2])
;; => {:name "David", :_child {:name "Petr"}}

#+end_src

**** reverse non-component references yield collections


#+begin_src clojure :results silent :exports code

(dx/pull db '[:name :_father] [:db/id 3])
;; => {:name "Thomas", :_father [:db/id 6]}

(dx/pull db '[:name :_father] [:db/id 1])
;; => {:name "Petr", :_father [[:db/id 3] [:db/id 2]]}

(dx/pull db '[:name {:_father [:name]}] [:db/id 3])
;; => {:name "Thomas", :_father {:name "Matthew"}}

(dx/pull db '[:name {:_father [:name]}] [:db/id 1])
;; => {:name "Petr", :_father [{:name "Thomas"} {:name "David"}]}

#+end_src

**** wildcard


#+begin_src clojure :results silent :exports code

(dx/pull db [:*] [:db/id 1])
;; =>
;; {:db/id 1, :name "Petr", :aka ["Devil" "Tupen"], :child [[:db/id 2] [:db/id 3]]}

(dx/pull db [:* :_child] [:db/id 2])
;; => {:db/id 2, :name "David", :father [:db/id 1], :_child [:db/id 1]}

#+end_src

**** missing attrs are dropped

#+begin_src clojure :results silent :exports code

(dx/pull db [:name {:child [:name]}] [:db/id 2])
;; => {:name "David"}

#+end_src

**** non matching results are removed from collections

#+begin_src clojure :results silent

(dx/pull db [:name {:child [:foo]}] [:db/id 1])
;; => {:name "Petr", :child []}

#+end_src

** datalog

#+begin_src clojure :results silent :exports code

(def db (dx/create-dx [{:db/id 1, :name "Ivan" :age 15}
                       {:db/id 2, :name "Petr" :age 37}
                       {:db/id 3, :name "Ivan" :age 37}
                       {:db/id 4, :age 15}]))

#+end_src

*** joins

unlike everything else, =doxa= does not return a set, but a =vector=, which has
far-reaching consequences

#+begin_src clojure :results silent :exports code

db
;; => #:db{:id {1 {:db/id 1, :name "Ivan", :age 15},
;;              2 {:db/id 2, :name "Petr", :age 37},
;;              3 {:db/id 3, :name "Ivan", :age 37},
;;              4 {:db/id 4, :age 15}}}


(dx/q [:find ?e
       :where [?e :name]]
  db)
;; => [[1] [2] [3]]

(dx/q [:find ?e ?v
       :where
       [?e :name "Ivan"]
       [?e :age ?v]]
  db)
;; => [[1 15] [3 37]]

#+end_src

each element is checked once, so the result in a normal =datalog= engine would be =[[1 1]
[1 3] [3 3]]=

#+begin_src clojure :results silent :exports code

db
;; => #:db{:id {1 {:db/id 1, :name "Ivan", :age 15},
;;              2 {:db/id 2, :name "Petr", :age 37},
;;              3 {:db/id 3, :name "Ivan", :age 37},
;;              4 {:db/id 4, :age 15}}}

(dx/q [:find ?e1 ?e2
       :where
       [?e1 :name ?n]
       [?e2 :name ?n]] db)
;; => [[1 3] [3 1]]

(dx/q [:find ?e1 ?e2 ?n
       :where
       [?e1 :name "Ivan"]
       [?e1 :age ?a]
       [?e2 :age ?a]
       [?e2 :name ?n]]
  db)
;; => [[3 2 "Petr"]]

#+end_src

**** many

=meander= is running underneath, so you can use all the functions available in the
=meander=, e.g. =scan=

#+begin_src clojure :results silent :exports code

(def db (dx/create-dx [{:db/id 1
                        :name  "Ivan"
                        :aka   ["ivolga" "pi"]}
                       {:db/id 2
                        :name  "Petr"
                        :aka   ["porosenok" "pi"]}]))

(dx/q [:find ?n1 ?n2
       :where
       [?e1 :aka (m/scan ?x)]
       [?e2 :aka (m/scan ?x)]
       [?e1 :name ?n1]
       [?e2 :name ?n2]]
  db)
;; => [["Ivan" "Petr"] ["Petr" "Ivan"]]
#+end_src

**** in


#+begin_src clojure :results silent :exports code

(def db (dx/create-dx [{:db/id 1, :name "Ivan" :age 15 :email "ivan@mail.ru"}
                       {:db/id 2, :name "Petr" :age 37 :email "petr@gmail.com"}
                       {:db/id 3, :name "Ivan" :age 37 :email "ivan@mail.ru"}]))

(dx/q [:find ?e
       :in ?attr ?value
       :where [?e ?attr ?value]]
  db :name "Ivan")
;; => [[1] [3]]

(dx/q [:find ?e
       :in ?attr [?value]
       :where [?e ?attr ?value]]
  db :name ["Ivan" "Petr"])
;; => [[1] [2] [3]]

(dx/q [:find ?e
       :in ?attr ?value
       :where [?e ?attr ?value]]
  db :age 37)
;; => [[2] [3]]

#+end_src

**** relation binding


#+begin_src clojure :results silent

(dx/q [:find ?e ?email
       :in [[?n ?email]]
       :where
       [?e :name ?n]
       [?e :email ?email]]
  db
  [["Ivan" "ivan@mail.ru"]
   ["Petr" "petr@gmail.com"]])
;; => [[1 "ivan@mail.ru"] [2 "petr@gmail.com"] [3 "ivan@mail.ru"]]

#+end_src

**** joins with idents

unfortunately, but using links in the form of =[?table ?id]= also entails
disadvantages and difficulties.

#+begin_src clojure :results silent :exports code

(def db (dx/create-dx [{:db/id 1
                        :name  "Ivan"
                        :friend   [{:db/id 2
                                    :name "Petr"}
                                   {:db/id 3
                                    :name "Oleg"}]}]))

db
;; {:db/id {2 {:db/id 2, :name "Petr"}
;;          3 {:db/id 3, :name "Oleg"}
;;          1 {:db/id 1,
;;             :name "Ivan",
;;             :friend [[:db/id 2] [:db/id 3]]}}}

#+end_src

references are always =vector= and must be treated as such

#+begin_src clojure :results silent :exports code

(dx/q [:find ?friends ...
       :where
       [?e :name "Ivan"]
       [?e :friend ?friends]]
  db)
;; => [[[:db/id 2] [:db/id 3]]]

#+end_src

if we try to do a simple join we get nothing =:(=

#+begin_src clojure :results silent :exports code

(dx/q [:find ?fname .
       :where
       [?e :name "Ivan"]
       [?e :friend ?friends]
       [?friends :name ?fname]]
  db)
;; => []

#+end_src

but knowing what a reference looks like, we can get around this

#+begin_src clojure :results silent :exports code

(dx/q [:find ?fname ...
       :where
       [?e :name "Ivan"]
       [?e :friend [_ ?friend]]
       [?friend :name ?fname]]
  db)
;; => ["Petr" "Oleg"]

#+end_src

at the moment my knowledge of meader internals is too limited to make it nicer

**** caching & matching

=q= allows results caching and re-run queries only if the last transaction changes
data that may have an impact. [[https://github.com/juji-io/editscript][editscript]] diffs are used, which, when converted
into datoms, are compared with each query datom. the most pessimistic scenario
is taken into consideration, because it is better to have false positives than
false negatives. in other words, it is better to re-run a query unnecessarily
than not to run it when you need to

#+begin_src clojure :results silent :exports code
(def conn_ (atom (dx/create-dx [] {::dx/with-diff? true})))
(meta @conn_)
;; => #:ribelo.doxa{:with-diff? true,
;;                  :last-transaction-timestamp 1632083203039,
;;                  :tx nil,
;;                  :cache_ #atom[{} 0x281c70de]}

#+end_src

#+begin_src clojure :results silent :exports code

(dx/commit! conn_ [:dx/put [:db/id 1] {:name "ivan"}])

@conn_
;; => #:db{:id {1 {:name "ivan", :db/id 1}}}

(meta @conn_)
;; => #:ribelo.doxa{:with-diff? true,
;;                  :last-transaction-timestamp 1632083289779,
;;                  :tx [[[:db/id] :+ {1 {:name "ivan", :db/id 1}}]],
;;                  :cache_ #atom[{} 0x281c70de],
;;                  :h -69594259}

(dx/-last-tx @conn_)
;; => [[:db/id] :+ {1 {:name "ivan", :db/id 1}}]

(-> (dx/-last-tx @conn_)
    (dx/-tx->datom))
;; => [:db/id 1 :name "ivan"]

(-> (dx/-last-tx-match-query?
     @conn_
     '[:find ?e
       :where
       [?e ?attr ?v]]))
;; => true

;; meander allows to match after each element of the datom
(-> (dx/-last-tx-match-query?
     @conn_
     '[:find ?e
       :where
       [:db/id ?e ?attr ?v]]))
;; => true

(-> (dx/-last-tx-match-query?
     @conn_
     '[:find ?e
       :where
       [:db/id 1 ?attr ?v]]))
;; => true

(-> (dx/-last-tx-match-query?
     @conn_
     '[:find ?e
       :where
       [:db/id 2 ?attr ?v]]))
;; => false

(-> (dx/-last-tx-match-query?
     @conn_
     '[:find ?e
       :where
       [?e ?attr "ivan"]]))
;; => true

(-> (dx/-last-tx-match-query?
     @conn_
     '[:find ?e
       :where
       [?e ?attr "petr"]]))
;; => false
#+end_src

each data returned by =q= has metadata attached to it showing whether the results
are fresh etc

#+begin_src clojure :results silent :exports code
^{::cache? true}
(defn do-query []
  ^{::dx/cache ::my-query}
  (dx/q [:find (pull [:*] [?table ?e]) .
         :where
         [?table ?e :name "ivan"]]
    @conn_))
(def r (do-query))
r
;; => {:name "ivan", :db/id 1}
(meta r)
;; => #:ribelo.doxa{:last-transaction-timestamp 1632083289779,
;;                  :last-query-timestamp nil,
;;                  :fresh? true}
(meta (do-query))
;; => #:ribelo.doxa{:last-transaction-timestamp 1632083289779,
;;                  :last-query-timestamp 1632084271082,
;;                  :fresh? false}
#+end_src

this allows you to write advanced queries that are not re-run until needed, and
thus views are re-rendered only when data changes.

#+begin_src clojure :results silent :exports code
@conn_
;; => #:db{:id {1 {:name "ivan", :db/id 1}}}

(defn find-petr []
  ^{::dx/cache? true}
  (dx/q [:find (pull [:*] [?table ?e]) .
         :where
         [?table ?e :name "petr"]]
    @conn_))

(::dx/fresh? (meta (find-petr)))
;; => true
(::dx/fresh? (meta (find-petr)))
;; => false
(dx/commit! conn_ [:dx/put [:db/id 1] :age 18])
@conn_
;; => #:db{:id {1 {:name "ivan", :db/id 1, :age 18}}}

;; data is still retrieved from the cache and the query is not executed again
(::dx/fresh? (meta (find-petr)))
;; => false

(dx/commit! conn_ [:dx/put [:db/id 2] :name "petr"])
@conn_
;; => #:db{:id {1 {:name "ivan", :db/id 1, :age 18}, 2 {:name "petr"}}}

(def r (find-petr))
r
;; => {:name "petr"}
(::dx/fresh? (meta r))
;; => true

;; query has been re-run and the data has been pulled correctly

(find-petr)
;; => {:name "petr"}

(::dx/fresh? (meta (find-petr)))
;; => false
#+end_src

what effect this has on performance can be found in the [[https://github.com/ribelo/doxa#query][benchmark]]

** benchmark

#+begin_src clojure :results silent :exports code

(require '[taoensso.encore :as enc])
(require '[meander.epsilon :as   m])
(require '[datascript.core :as   d])
(require '[ribelo.doxa     :as  dx])

#+end_src

it is rare for a spa database to contain things that cannot be divided into
tables or assigned categories. so let's create 100k maps for 10 different
categories

#+begin_src clojure :results silent :exports code

(let [next-eid (volatile! 0)]

  (defn random-man []
    {:db/id     (vswap! next-eid inc)
     :name      (rand-nth ["Ivan" "Petr" "Sergei" "Oleg" "Yuri" "Dmitry" "Fedor" "Denis"])
     :last-name (rand-nth ["Ivanov" "Petrov" "Sidorov" "Kovalev" "Kuznetsov" "Voronoi"])
     :alias     (vec
                 (repeatedly (rand-int 10) #(rand-nth ["A. C. Q. W." "A. J. Finn" "A.A. Fair" "Aapeli" "Aaron Wolfe" "Abigail Van Buren" "Jeanne Phillips" "Abram Tertz" "Abu Nuwas" "Acton Bell" "Adunis"])))
     :age       (rand-int 100)
     :salary    (rand-int 100000)
     :friend    {:db/ref-id (rand-int 20000)}})

  (defn random-fruit []
    {:fruit/id     (vswap! next-eid inc)
     :name      (rand-nth ["Avocado" "Grape" "Plum" "Apple" "Orange"])
     :price     (rand-int 100)})

  (defn random-vegetable []
    {:vegetable/id     (vswap! next-eid inc)
     :name      (rand-nth ["Onion" "Cabbage" "Pea" "Tomatto" "Lettuce"])
     :price     (rand-int 100)})

  (defn random-car []
    {:car/id     (vswap! next-eid inc)
     :name      (rand-nth ["Audi" "Mercedes" "BMW" "Ford" "Honda" "Toyota"])
     :price     (rand-int 100)})

  (defn random-animal []
    {:animal/id     (vswap! next-eid inc)
     :name      (rand-nth ["Otter" "Dog" "Panda" "Lynx" "Cat" "Lion"])
     :price     (rand-int 100)})

  (defn random-cat []
    {:cat/id     (vswap! next-eid inc)
     :name      (rand-nth ["Traditional Persian" "Ocicat" "Munchkin cat" "Persian cat" "Burmese cat"])
     :price     (rand-int 100)})

  (defn random-dog []
    {:dog/id     (vswap! next-eid inc)
     :name      (rand-nth ["Croatian Shepherd" "Deutch Langhaar" "Miniature Pincher" "Italian Sighthound" "Jack Russell Terrier"])
     :price     (rand-int 100)})

  (defn random-country []
    {:country/id     (vswap! next-eid inc)
     :name      (rand-nth ["Seychelles" "Greenland" "Iceland" "Bahrain" "Bhutan"])
     :price     (rand-int 100)})

  (defn random-language []
    {:language/id     (vswap! next-eid inc)
     :name      (rand-nth ["Malagasy" "Kashmiri" "Amharic" "Inuktitut" "Esperanto"])
     :price     (rand-int 100)})

  (defn random-marijuana-strain []
    {:marijuana/id     (vswap! next-eid inc)
     :name      (rand-nth ["Lemonder" "Black-Mamba" "Blueberry-Space-Cake" "Strawberry-Amnesia"])
     :price     (rand-int 100)})

  (defn random-planet []
    {:planet/id     (vswap! next-eid inc)
     :name      (rand-nth ["Pluto" "Saturn" "Venus" "Mars" "Jupyter"])
     :price     (rand-int 100)}))

(def people           (repeatedly random-man))
(def fruit            (repeatedly random-fruit))
(def vegetable        (repeatedly random-vegetable))
(def car              (repeatedly random-car))
(def animal           (repeatedly random-animal))
(def cat              (repeatedly random-cat))
(def dog              (repeatedly random-dog))
(def country          (repeatedly random-country))
(def language         (repeatedly random-language))
(def marijuana-strain (repeatedly random-marijuana-strain))

(def planet           (repeatedly random-planet))

(def people50k           (shuffle (take 50000 people)))

(def fruit10k            (shuffle (take 10000 fruit)))
(def vegetable10k        (shuffle (take 10000 vegetable)))
(def car10k              (shuffle (take 10000 car)))
(def animal10k           (shuffle (take 10000 animal)))
(def cat10k              (shuffle (take 10000 cat)))
(def dog10k              (shuffle (take 10000 dog)))
(def country10k          (shuffle (take 10000 country)))
(def language10k         (shuffle (take 10000 language)))
(def marijuana-strain10k (shuffle (take 10000 marijuana-strain)))
(def planet10k           (shuffle (take 10000 planet)))

(def data100k (enc/into-all []
                            fruit10k vegetable10k car10k animal10k cat10k dog10k
                            country10k language10k marijuana-strain10k planet10k))

(def schema
  {:friend {:db/valueType   :db.type/ref
            :db/cardinality :db.cardinality/many}
   :alias   {:db/cardinality :db.cardinality/many}})
#+end_src

*** transaction

**** adding data one transaction at a time


#+begin_src clojure :results silent :exports code

(defn datascript-add-1 [data]
  (enc/qb 1
    (reduce
     (fn [db p]
       (-> db
           (d/db-with [[:db/add (:db/id p) :name      (:name p)]])
           (d/db-with [[:db/add (:db/id p) :last-name (:last-name p)]])
           (d/db-with [[:db/add (:db/id p) :age       (:age p)]])
           (d/db-with [[:db/add (:db/id p) :salary    (:salary p)]])))
     (d/empty-db schema)
     data)))

(defn doxa-add-1 [data]
  (enc/qb 1
    (reduce
     (fn [db p]
       (dx/commit db [[:dx/put p]]))
     {}
     data)))

;; result in ms
[(datascript-add-1 people50k) (doxa-add-1 people50k)]
;; clj => [1277.13 204.93]

#+end_src

**** add all data in single transaction


#+begin_src clojure :results silent :exports code

(defn datascript-add-all []
  (enc/qb 1
    (d/db-with (d/empty-db schema) people50k)))

(defn doxa-add-all []
  (enc/qb 1
    (->> (into []
               (map (fn [p] [:dx/put p]))
               people50k)
         (dx/commit {}))))

[(datascript-add-all) (doxa-add-all)]
;; clj => [1483.59 42.56]

#+end_src

*** query

**** can we be faster than datascript? yes!
:PROPERTIES:
:ID:       cc58c12e-7411-4844-a805-5bbfdac1cbba
:END:

#+begin_src clojure :results silent :exports code

(def db100k
  (d/db-with (d/empty-db)
             (mapv
              (fn [m]
                (reduce-kv
                 (fn [acc k v]
                   (if (= :id (name k))
                     (assoc acc :db/id v)
                     (assoc acc k v)))
                 {}
                 m))
              data100k)))

(def dx100k (dx/create-dx data100k))

#+end_src

#+begin_src clojure :results silent :exports none

(defn datascript-query []
  (enc/qb 1e1
    (d/q '[:find ?e
           :where
           [?e :name "Avocado"]
           [?e :price ?price]
           [(< ?price 50)]]
      db100k)))

(defn dx-query []
  (enc/qb 1e1
    (dx/q [:find ?e
           :where
           [?e :name "Avocado"]
           [?e :price ?price]
           [(< ?price 50)]]
      dx100k)))

(defn cached-dx-query []
  (enc/qb 1e1
    ^{::dx/cache? true}
    (dx/q [:find ?e
           :where
           [?e :name "Avocado"]
           [?e :price ?price]
           [(< ?price 50)]]
      dx100k)))

(defn fast-dx-query []
  (enc/qb 1e1
    (dx/q [:find ?e
           :in ?table
           :where
           [?table ?e :name "Avocado"]
           [?table ?e :price ?price]
           [(< ?price 50)]]
      dx100k :fruit/id)))

(defn fast-cached-dx-query []
  (enc/qb 1e1
    ^{::dx/cache :any-value}
    (dx/q [:find ?e
           :in ?table
           :where
           [?table ?e :name "Avocado"]
           [?table ?e :price ?price]
           [(< ?price 50)]]
      dx100k :fruit/id)))

[(datascript-query) (dx-query) (cached-dx-query) (fast-dx-query) (fast-cached-dx-query)]
;; clj => [159.42 531.67 0.05 50.15 0.03]
#+end_src

**** query by one condition


#+begin_src clojure :results silent :exports code

(def db50k
  (d/db-with (d/empty-db)
             (mapv
              (fn [m]
                (reduce-kv
                 (fn [acc k v]
                   (if (= :id (name k))
                     (assoc acc :db/id v)
                     (assoc acc k v)))
                 {}
                 m))
              people50k)))

(def dx50k (dx/create-dx people50k))

#+end_src

#+begin_src clojure :results silent :exports code

(defn datascript-q1 []
  (enc/qb 1
    (d/q '[:find ?e
           :where [?e :name "Ivan"]]
      db50k)))

(defn dx-q1 []
  (enc/qb 1
    (dx/q [:find  ?e
           :where [?e :name "Ivan"]]
      dx50k)))

[(datascript-q1) (dx-q1)]
;; cljs => [   9    51]
;; clj  => [5.45 32.09]

#+end_src

**** two conditions


#+begin_src clojure :results silent :exports code

(defn datascript-q2 []
  (enc/qb 1e1
    (d/q '[:find ?e ?a
           :where [?e :name "Ivan"]
           [?e :age ?a]]
      db50k)))

(defn dx-q2 []
  (enc/qb 1e1
    (dx/q [ :find  [?e ?a]
             :where [?e :name "Ivan"]
            [?e :age ?a]]
      dx50k)))

[(datascript-q2) (dx-q2)]
;; cljs => [   242    618]
;; clj  => [152.96 317.74]
#+end_src

**** 3

#+begin_src clojure :results silent :exports code

(defn datascript-q3 []
  (enc/qb 1e1
    (d/q '[:find ?e ?a
           :where [?e :name "Ivan"]
           [?e :age ?a]
           [?e :sex :male]]
      db50k)))

(defn dx-q3 []
  (enc/qb 1e1
    (dx/q [:find  [?e ?a]
             :where [?e :name "Ivan"]
                     [?e :age ?a]
            [?e :sex :male]]
      dx50k)))

[(datascript-q3) (dx-q3)]
;; cljs => [   409    646]
;; clj  => [133.26 307.05]
#+end_src

**** 4

#+begin_src clojure :results silent :exports code

(defn datascript-q4 []
  (enc/qb 1e1
    (d/q '[:find ?e ?l ?a
           :where [?e :name "Ivan"]
           [?e :last-name ?l]
           [?e :age ?a]
           [?e :sex :male]]
      db50k)))

(defn dx-q4 []
  (enc/qb 1e1
    (doall
     (dx/q [:find [?e ?l ?a]
            :where [?e :name "Ivan"]
            [?e :last-name ?l]
            [?e :age ?a]
            [?e :sex :male]]
       dx50k))))

[(datascript-q4) (dx-q4)]
;; cljs => [  588    681]
;; clj  => [252.49 310.05]

#+end_src

**** one pred

#+begin_src clojure :results silent :exports code

(defn datascript-qpred1 []
  (enc/qb 1e1
    (d/q '[:find ?e ?s
           :where [?e :salary ?s]
           [(> ?s 50000)]]
      db50k)))

(defn dx-qpred1 []
  (enc/qb 1e1
    (dx/q [:find ?e ?s
          :where [?e :salary ?s]
          [(> ?s 50000)]]
      dx50k)))

[(datascript-qpred1) (dx-qpred1)]
;; cljs => [  321    959]
;; clj  => [259.34 384.9]

#+end_src

*** pull

**** one key

#+begin_src clojure :results silent :exports code

(defn datascript-pull1 []
  (enc/qb 1e3
    (d/pull db100k [:name] (rand-int 20000))))

(defn dx-pull1 []
  (enc/qb 1e3
    (dx/pull dx100k [:name] [:db/id (rand-int 20000)])))

[(datascript-pull1) (dx-pull1)]
;; cljs => [   15    8]
;; clj  => [14.43 1.36]

#+end_src

**** entire map

#+begin_src clojure :results silent :exports code

(defn datascript-pull2 []
  (enc/qb 1e3
    (d/pull db100k ['*] (rand-int 20000))))

(defn dx-pull2 []
  (enc/qb 1e3
    (dx/pull dx100k [:*] [:db/id (rand-int 20000)])))

[(datascript-pull2) (dx-pull2)]
;; cljs => [   43   11]
;; clj  => [38.52 3.81]

#+end_src

**** joins

#+begin_src clojure :results silent

(defn datascript-pull3 []
  (enc/qb 1e3
    (d/pull db100k [:name {:friend [:name]}] (rand-int 20000))))

(defn dx-pull3 []
  (enc/qb 1e3
    (dx/pull dx100k [:name {:friend [:name]}] [:db/id (rand-int 20000)])))

[(datascript-pull3) (dx-pull3)]
;; cljs => [   42   19]
;; clj  => [20.63 2.84]
#+end_src
